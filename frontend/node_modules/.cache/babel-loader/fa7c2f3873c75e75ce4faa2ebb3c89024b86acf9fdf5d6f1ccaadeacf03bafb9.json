{"ast":null,"code":"var _jsxFileName = \"C:\\\\vishu study\\\\new pj\\\\New folder\\\\frontend\\\\src\\\\context\\\\InterviewContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useReducer, useEffect } from 'react';\nimport { io } from 'socket.io-client';\nimport axios from 'axios';\nimport toast from 'react-hot-toast';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst InterviewContext = /*#__PURE__*/createContext();\n\n// Initial state\nconst initialState = {\n  // Session data\n  sessionId: null,\n  candidateName: '',\n  questions: [],\n  currentQuestionIndex: 0,\n  // Interview status\n  isInterviewActive: false,\n  isInterviewCompleted: false,\n  // Real-time metrics\n  metrics: {\n    eyeContactPercentage: 0,\n    confidenceScore: 0,\n    speechClarity: 0,\n    emotionScores: {},\n    warnings: []\n  },\n  // Media streams\n  videoStream: null,\n  audioStream: null,\n  // UI state\n  isLoading: false,\n  error: null,\n  // Results\n  finalResults: null,\n  // Socket connection\n  socket: null,\n  isConnected: false,\n  // Resume analysis\n  resumeAnalysis: null\n};\n\n// Action types\nconst ACTIONS = {\n  SET_SESSION_ID: 'SET_SESSION_ID',\n  SET_CANDIDATE_NAME: 'SET_CANDIDATE_NAME',\n  SET_QUESTIONS: 'SET_QUESTIONS',\n  SET_CURRENT_QUESTION: 'SET_CURRENT_QUESTION',\n  SET_INTERVIEW_ACTIVE: 'SET_INTERVIEW_ACTIVE',\n  SET_INTERVIEW_COMPLETED: 'SET_INTERVIEW_COMPLETED',\n  UPDATE_METRICS: 'UPDATE_METRICS',\n  SET_VIDEO_STREAM: 'SET_VIDEO_STREAM',\n  SET_AUDIO_STREAM: 'SET_AUDIO_STREAM',\n  SET_LOADING: 'SET_LOADING',\n  SET_ERROR: 'SET_ERROR',\n  SET_FINAL_RESULTS: 'SET_FINAL_RESULTS',\n  SET_SOCKET: 'SET_SOCKET',\n  SET_CONNECTED: 'SET_CONNECTED',\n  RESET_STATE: 'RESET_STATE',\n  ADD_FOLLOWUP_QUESTION: 'ADD_FOLLOWUP_QUESTION',\n  SET_RESUME_ANALYSIS: 'SET_RESUME_ANALYSIS'\n};\n\n// Reducer function\nfunction interviewReducer(state, action) {\n  switch (action.type) {\n    case ACTIONS.SET_SESSION_ID:\n      return {\n        ...state,\n        sessionId: action.payload\n      };\n    case ACTIONS.SET_CANDIDATE_NAME:\n      return {\n        ...state,\n        candidateName: action.payload\n      };\n    case ACTIONS.SET_QUESTIONS:\n      return {\n        ...state,\n        questions: action.payload\n      };\n    case ACTIONS.SET_CURRENT_QUESTION:\n      return {\n        ...state,\n        currentQuestionIndex: action.payload\n      };\n    case ACTIONS.SET_INTERVIEW_ACTIVE:\n      return {\n        ...state,\n        isInterviewActive: action.payload\n      };\n    case ACTIONS.SET_INTERVIEW_COMPLETED:\n      return {\n        ...state,\n        isInterviewCompleted: action.payload\n      };\n    case ACTIONS.UPDATE_METRICS:\n      return {\n        ...state,\n        metrics: {\n          ...state.metrics,\n          ...action.payload\n        }\n      };\n    case ACTIONS.SET_VIDEO_STREAM:\n      return {\n        ...state,\n        videoStream: action.payload\n      };\n    case ACTIONS.SET_AUDIO_STREAM:\n      return {\n        ...state,\n        audioStream: action.payload\n      };\n    case ACTIONS.SET_LOADING:\n      return {\n        ...state,\n        isLoading: action.payload\n      };\n    case ACTIONS.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload\n      };\n    case ACTIONS.SET_FINAL_RESULTS:\n      return {\n        ...state,\n        finalResults: action.payload\n      };\n    case ACTIONS.SET_SOCKET:\n      return {\n        ...state,\n        socket: action.payload\n      };\n    case ACTIONS.SET_CONNECTED:\n      return {\n        ...state,\n        isConnected: action.payload\n      };\n    case ACTIONS.RESET_STATE:\n      return initialState;\n    case ACTIONS.ADD_FOLLOWUP_QUESTION:\n      return {\n        ...state,\n        questions: [...state.questions, action.payload]\n      };\n    case ACTIONS.SET_RESUME_ANALYSIS:\n      return {\n        ...state,\n        resumeAnalysis: action.payload\n      };\n    default:\n      return state;\n  }\n}\n\n// Provider component\nexport function InterviewProvider({\n  children\n}) {\n  _s();\n  const [state, dispatch] = useReducer(interviewReducer, initialState);\n\n  // Initialize socket connection\n  useEffect(() => {\n    const socket = io('http://localhost:5000', {\n      transports: ['websocket'],\n      autoConnect: false\n    });\n    socket.on('connect', () => {\n      dispatch({\n        type: ACTIONS.SET_CONNECTED,\n        payload: true\n      });\n      console.log('Connected to server');\n    });\n    socket.on('disconnect', () => {\n      dispatch({\n        type: ACTIONS.SET_CONNECTED,\n        payload: false\n      });\n      console.log('Disconnected from server');\n    });\n    socket.on('metrics_update', data => {\n      dispatch({\n        type: ACTIONS.UPDATE_METRICS,\n        payload: data.metrics\n      });\n    });\n    socket.on('error', error => {\n      dispatch({\n        type: ACTIONS.SET_ERROR,\n        payload: error.message\n      });\n      toast.error('Connection error: ' + error.message);\n    });\n    dispatch({\n      type: ACTIONS.SET_SOCKET,\n      payload: socket\n    });\n    return () => {\n      socket.disconnect();\n    };\n  }, []);\n\n  // API functions\n  const api = {\n    // Health check\n    checkHealth: async () => {\n      try {\n        const response = await axios.get('/api/health');\n        return response.data;\n      } catch (error) {\n        console.error('Health check failed:', error);\n        throw error;\n      }\n    },\n    // Upload resume\n    uploadResume: async file => {\n      dispatch({\n        type: ACTIONS.SET_LOADING,\n        payload: true\n      });\n      try {\n        const formData = new FormData();\n        formData.append('resume', file);\n        const response = await axios.post('/api/upload-resume', formData, {\n          headers: {\n            'Content-Type': 'multipart/form-data'\n          }\n        });\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n        return response.data;\n      } catch (error) {\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n        dispatch({\n          type: ACTIONS.SET_ERROR,\n          payload: error.message\n        });\n        toast.error('Failed to upload resume: ' + error.message);\n        throw error;\n      }\n    },\n    // Start interview\n    startInterview: async (candidateName, questions) => {\n      dispatch({\n        type: ACTIONS.SET_LOADING,\n        payload: true\n      });\n      try {\n        const response = await axios.post('/api/start-interview', {\n          candidate_name: candidateName,\n          questions: questions\n        });\n        const {\n          session_id\n        } = response.data;\n        dispatch({\n          type: ACTIONS.SET_SESSION_ID,\n          payload: session_id\n        });\n        dispatch({\n          type: ACTIONS.SET_CANDIDATE_NAME,\n          payload: candidateName\n        });\n        dispatch({\n          type: ACTIONS.SET_QUESTIONS,\n          payload: questions\n        });\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n\n        // Join socket room\n        if (state.socket) {\n          state.socket.emit('join_session', {\n            session_id\n          });\n        }\n        toast.success('Interview session started!');\n        return response.data;\n      } catch (error) {\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n        dispatch({\n          type: ACTIONS.SET_ERROR,\n          payload: error.message\n        });\n        toast.error('Failed to start interview: ' + error.message);\n        throw error;\n      }\n    },\n    // Process video frame\n    processFrame: async frameData => {\n      if (!state.sessionId) return;\n      try {\n        // Convert base64 to blob for file upload\n        const base64Data = frameData.split(',')[1]; // Remove data:image/jpeg;base64, prefix\n        const byteCharacters = atob(base64Data);\n        const byteNumbers = new Array(byteCharacters.length);\n        for (let i = 0; i < byteCharacters.length; i++) {\n          byteNumbers[i] = byteCharacters.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        const blob = new Blob([byteArray], {\n          type: 'image/jpeg'\n        });\n\n        // Create FormData for file upload\n        const formData = new FormData();\n        formData.append('frame', blob, 'frame.jpg');\n        formData.append('session_id', state.sessionId);\n        const response = await axios.post('/api/process-frame', formData, {\n          headers: {\n            'Content-Type': 'multipart/form-data'\n          }\n        });\n\n        // Update metrics with the response data\n        if (response.data.success) {\n          // Update metrics based on the response\n          const metricsUpdate = {\n            face_detected: response.data.face_detected,\n            eyeContactPercentage: response.data.eye_contact ? 100 : 0,\n            confidenceScore: response.data.confidence || 0\n          };\n\n          // If we have eye contact metrics, update them too\n          if (response.data.eye_contact_metrics) {\n            metricsUpdate.eyeContactDuration = response.data.eye_contact_metrics.total_eye_contact_time;\n            metricsUpdate.eyeContactStreak = response.data.eye_contact_metrics.current_streak;\n            metricsUpdate.longestEyeContactStreak = response.data.eye_contact_metrics.longest_streak;\n            metricsUpdate.eyeContactWarnings = response.data.eye_contact_metrics.warnings_triggered;\n          }\n          dispatch({\n            type: ACTIONS.UPDATE_METRICS,\n            payload: metricsUpdate\n          });\n        }\n        return response.data;\n      } catch (error) {\n        console.error('Frame processing error:', error);\n        // Don't show toast for frame processing errors as they're frequent\n      }\n    },\n    // Process audio\n    processAudio: async audioData => {\n      if (!state.sessionId) return;\n      try {\n        const response = await axios.post('/api/process-audio', {\n          session_id: state.sessionId,\n          audio_data: audioData\n        });\n        return response.data;\n      } catch (error) {\n        console.error('Audio processing error:', error);\n      }\n    },\n    // End interview\n    endInterview: async () => {\n      if (!state.sessionId) return;\n      dispatch({\n        type: ACTIONS.SET_LOADING,\n        payload: true\n      });\n      try {\n        const response = await axios.post(`/api/end-interview/${state.sessionId}`);\n        dispatch({\n          type: ACTIONS.SET_FINAL_RESULTS,\n          payload: response.data.final_report\n        });\n        dispatch({\n          type: ACTIONS.SET_INTERVIEW_COMPLETED,\n          payload: true\n        });\n        dispatch({\n          type: ACTIONS.SET_INTERVIEW_ACTIVE,\n          payload: false\n        });\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n        toast.success('Interview completed successfully!');\n        return response.data;\n      } catch (error) {\n        dispatch({\n          type: ACTIONS.SET_LOADING,\n          payload: false\n        });\n        dispatch({\n          type: ACTIONS.SET_ERROR,\n          payload: error.message\n        });\n        toast.error('Failed to end interview: ' + error.message);\n        throw error;\n      }\n    },\n    // Get session details\n    getSessionDetails: async sessionId => {\n      try {\n        const response = await axios.get(`/api/sessions/${sessionId}`);\n        return response.data;\n      } catch (error) {\n        console.error('Failed to get session details:', error);\n        throw error;\n      }\n    },\n    // Get all sessions\n    getAllSessions: async () => {\n      try {\n        const response = await axios.get('/api/sessions');\n        return response.data;\n      } catch (error) {\n        console.error('Failed to get sessions:', error);\n        throw error;\n      }\n    },\n    // Get current metrics for a session\n    getCurrentMetrics: async sessionId => {\n      try {\n        const response = await axios.get(`/api/sessions/${sessionId}/metrics`);\n        if (response.data.success) {\n          dispatch({\n            type: ACTIONS.UPDATE_METRICS,\n            payload: response.data.metrics\n          });\n        }\n        return response.data;\n      } catch (error) {\n        console.error('Failed to get current metrics:', error);\n        throw error;\n      }\n    },\n    // Request metrics update via WebSocket\n    requestMetricsUpdate: () => {\n      if (state.socket && state.sessionId) {\n        state.socket.emit('request_metrics', {\n          session_id: state.sessionId\n        });\n      }\n    },\n    // Submit answer and get follow-up question\n    submitAnswer: async (questionId, answerText, currentQuestion) => {\n      if (!state.sessionId) return;\n      try {\n        const response = await axios.post('/api/submit-answer', {\n          session_id: state.sessionId,\n          question_id: questionId,\n          answer_text: answerText,\n          current_question: currentQuestion\n        });\n        if (response.data.success) {\n          // Update metrics with the response\n          dispatch({\n            type: ACTIONS.UPDATE_METRICS,\n            payload: response.data.updated_metrics\n          });\n\n          // Store the follow-up question\n          if (response.data.followup_question) {\n            dispatch({\n              type: ACTIONS.ADD_FOLLOWUP_QUESTION,\n              payload: response.data.followup_question\n            });\n          }\n        }\n        return response.data;\n      } catch (error) {\n        console.error('Failed to submit answer:', error);\n        throw error;\n      }\n    },\n    // Generate follow-up question\n    generateFollowupQuestion: async (currentQuestion, previousAnswer, questionHistory) => {\n      if (!state.sessionId) return;\n      try {\n        const response = await axios.post('/api/generate-followup-question', {\n          session_id: state.sessionId,\n          current_question: currentQuestion,\n          previous_answer: previousAnswer,\n          question_history: questionHistory\n        });\n        return response.data;\n      } catch (error) {\n        console.error('Failed to generate follow-up question:', error);\n        throw error;\n      }\n    },\n    // Request eye contact status update\n    requestEyeContactStatus: () => {\n      if (state.socket && state.sessionId) {\n        state.socket.emit('request_eye_contact_status', {\n          session_id: state.sessionId\n        });\n      }\n    },\n    // Get current eye contact status\n    getEyeContactStatus: async () => {\n      if (!state.sessionId) return;\n      try {\n        const response = await axios.get(`/api/eye-contact-status/${state.sessionId}`);\n        return response.data;\n      } catch (error) {\n        console.error('Failed to get eye contact status:', error);\n        throw error;\n      }\n    },\n    // Analyze resume\n    analyzeResume: async resumeFile => {\n      if (!state.sessionId) return;\n      try {\n        const formData = new FormData();\n        formData.append('resume', resumeFile);\n        formData.append('session_id', state.sessionId);\n        const response = await axios.post('/api/analyze-resume', formData, {\n          headers: {\n            'Content-Type': 'multipart/form-data'\n          }\n        });\n        if (response.data.success) {\n          // Store resume analysis in context\n          dispatch({\n            type: ACTIONS.SET_RESUME_ANALYSIS,\n            payload: response.data.resume_analysis\n          });\n        }\n        return response.data;\n      } catch (error) {\n        console.error('Failed to analyze resume:', error);\n        throw error;\n      }\n    }\n  };\n\n  // Utility functions\n  const utils = {\n    // Get current question\n    getCurrentQuestion: () => {\n      return state.questions[state.currentQuestionIndex] || null;\n    },\n    // Move to next question\n    nextQuestion: () => {\n      if (state.currentQuestionIndex < state.questions.length - 1) {\n        dispatch({\n          type: ACTIONS.SET_CURRENT_QUESTION,\n          payload: state.currentQuestionIndex + 1\n        });\n        return true;\n      }\n      return false;\n    },\n    // Move to previous question\n    previousQuestion: () => {\n      if (state.currentQuestionIndex > 0) {\n        dispatch({\n          type: ACTIONS.SET_CURRENT_QUESTION,\n          payload: state.currentQuestionIndex - 1\n        });\n        return true;\n      }\n      return false;\n    },\n    // Reset state\n    resetState: () => {\n      dispatch({\n        type: ACTIONS.RESET_STATE\n      });\n    },\n    // Connect socket\n    connectSocket: () => {\n      if (state.socket && !state.isConnected) {\n        state.socket.connect();\n      }\n    },\n    // Disconnect socket\n    disconnectSocket: () => {\n      if (state.socket && state.isConnected) {\n        state.socket.disconnect();\n      }\n    }\n  };\n  const value = {\n    ...state,\n    api,\n    utils,\n    dispatch\n  };\n  return /*#__PURE__*/_jsxDEV(InterviewContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 534,\n    columnNumber: 5\n  }, this);\n}\n\n// Custom hook to use the context\n_s(InterviewProvider, \"bgCdjuTOmPdSBRwTap80EFd9Y3U=\");\n_c = InterviewProvider;\nexport function useInterview() {\n  _s2();\n  const context = useContext(InterviewContext);\n  if (!context) {\n    throw new Error('useInterview must be used within an InterviewProvider');\n  }\n  return context;\n}\n_s2(useInterview, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"InterviewProvider\");","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","io","axios","toast","jsxDEV","_jsxDEV","InterviewContext","initialState","sessionId","candidateName","questions","currentQuestionIndex","isInterviewActive","isInterviewCompleted","metrics","eyeContactPercentage","confidenceScore","speechClarity","emotionScores","warnings","videoStream","audioStream","isLoading","error","finalResults","socket","isConnected","resumeAnalysis","ACTIONS","SET_SESSION_ID","SET_CANDIDATE_NAME","SET_QUESTIONS","SET_CURRENT_QUESTION","SET_INTERVIEW_ACTIVE","SET_INTERVIEW_COMPLETED","UPDATE_METRICS","SET_VIDEO_STREAM","SET_AUDIO_STREAM","SET_LOADING","SET_ERROR","SET_FINAL_RESULTS","SET_SOCKET","SET_CONNECTED","RESET_STATE","ADD_FOLLOWUP_QUESTION","SET_RESUME_ANALYSIS","interviewReducer","state","action","type","payload","InterviewProvider","children","_s","dispatch","transports","autoConnect","on","console","log","data","message","disconnect","api","checkHealth","response","get","uploadResume","file","formData","FormData","append","post","headers","startInterview","candidate_name","session_id","emit","success","processFrame","frameData","base64Data","split","byteCharacters","atob","byteNumbers","Array","length","i","charCodeAt","byteArray","Uint8Array","blob","Blob","metricsUpdate","face_detected","eye_contact","confidence","eye_contact_metrics","eyeContactDuration","total_eye_contact_time","eyeContactStreak","current_streak","longestEyeContactStreak","longest_streak","eyeContactWarnings","warnings_triggered","processAudio","audioData","audio_data","endInterview","final_report","getSessionDetails","getAllSessions","getCurrentMetrics","requestMetricsUpdate","submitAnswer","questionId","answerText","currentQuestion","question_id","answer_text","current_question","updated_metrics","followup_question","generateFollowupQuestion","previousAnswer","questionHistory","previous_answer","question_history","requestEyeContactStatus","getEyeContactStatus","analyzeResume","resumeFile","resume_analysis","utils","getCurrentQuestion","nextQuestion","previousQuestion","resetState","connectSocket","connect","disconnectSocket","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useInterview","_s2","context","Error","$RefreshReg$"],"sources":["C:/vishu study/new pj/New folder/frontend/src/context/InterviewContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect } from 'react';\r\nimport { io } from 'socket.io-client';\r\nimport axios from 'axios';\r\nimport toast from 'react-hot-toast';\r\n\r\n// Create context\r\nconst InterviewContext = createContext();\r\n\r\n// Initial state\r\nconst initialState = {\r\n  // Session data\r\n  sessionId: null,\r\n  candidateName: '',\r\n  questions: [],\r\n  currentQuestionIndex: 0,\r\n  \r\n  // Interview status\r\n  isInterviewActive: false,\r\n  isInterviewCompleted: false,\r\n  \r\n  // Real-time metrics\r\n  metrics: {\r\n    eyeContactPercentage: 0,\r\n    confidenceScore: 0,\r\n    speechClarity: 0,\r\n    emotionScores: {},\r\n    warnings: []\r\n  },\r\n  \r\n  // Media streams\r\n  videoStream: null,\r\n  audioStream: null,\r\n  \r\n  // UI state\r\n  isLoading: false,\r\n  error: null,\r\n  \r\n  // Results\r\n  finalResults: null,\r\n  \r\n  // Socket connection\r\n  socket: null,\r\n  isConnected: false,\r\n\r\n  // Resume analysis\r\n  resumeAnalysis: null\r\n};\r\n\r\n// Action types\r\nconst ACTIONS = {\r\n  SET_SESSION_ID: 'SET_SESSION_ID',\r\n  SET_CANDIDATE_NAME: 'SET_CANDIDATE_NAME',\r\n  SET_QUESTIONS: 'SET_QUESTIONS',\r\n  SET_CURRENT_QUESTION: 'SET_CURRENT_QUESTION',\r\n  SET_INTERVIEW_ACTIVE: 'SET_INTERVIEW_ACTIVE',\r\n  SET_INTERVIEW_COMPLETED: 'SET_INTERVIEW_COMPLETED',\r\n  UPDATE_METRICS: 'UPDATE_METRICS',\r\n  SET_VIDEO_STREAM: 'SET_VIDEO_STREAM',\r\n  SET_AUDIO_STREAM: 'SET_AUDIO_STREAM',\r\n  SET_LOADING: 'SET_LOADING',\r\n  SET_ERROR: 'SET_ERROR',\r\n  SET_FINAL_RESULTS: 'SET_FINAL_RESULTS',\r\n  SET_SOCKET: 'SET_SOCKET',\r\n  SET_CONNECTED: 'SET_CONNECTED',\r\n  RESET_STATE: 'RESET_STATE',\r\n  ADD_FOLLOWUP_QUESTION: 'ADD_FOLLOWUP_QUESTION',\r\n  SET_RESUME_ANALYSIS: 'SET_RESUME_ANALYSIS'\r\n};\r\n\r\n// Reducer function\r\nfunction interviewReducer(state, action) {\r\n  switch (action.type) {\r\n    case ACTIONS.SET_SESSION_ID:\r\n      return { ...state, sessionId: action.payload };\r\n    \r\n    case ACTIONS.SET_CANDIDATE_NAME:\r\n      return { ...state, candidateName: action.payload };\r\n    \r\n    case ACTIONS.SET_QUESTIONS:\r\n      return { ...state, questions: action.payload };\r\n    \r\n    case ACTIONS.SET_CURRENT_QUESTION:\r\n      return { ...state, currentQuestionIndex: action.payload };\r\n    \r\n    case ACTIONS.SET_INTERVIEW_ACTIVE:\r\n      return { ...state, isInterviewActive: action.payload };\r\n    \r\n    case ACTIONS.SET_INTERVIEW_COMPLETED:\r\n      return { ...state, isInterviewCompleted: action.payload };\r\n    \r\n    case ACTIONS.UPDATE_METRICS:\r\n      return { \r\n        ...state, \r\n        metrics: { ...state.metrics, ...action.payload }\r\n      };\r\n    \r\n    case ACTIONS.SET_VIDEO_STREAM:\r\n      return { ...state, videoStream: action.payload };\r\n    \r\n    case ACTIONS.SET_AUDIO_STREAM:\r\n      return { ...state, audioStream: action.payload };\r\n    \r\n    case ACTIONS.SET_LOADING:\r\n      return { ...state, isLoading: action.payload };\r\n    \r\n    case ACTIONS.SET_ERROR:\r\n      return { ...state, error: action.payload };\r\n    \r\n    case ACTIONS.SET_FINAL_RESULTS:\r\n      return { ...state, finalResults: action.payload };\r\n    \r\n    case ACTIONS.SET_SOCKET:\r\n      return { ...state, socket: action.payload };\r\n    \r\n    case ACTIONS.SET_CONNECTED:\r\n      return { ...state, isConnected: action.payload };\r\n    \r\n    case ACTIONS.RESET_STATE:\r\n      return initialState;\r\n    \r\n    case ACTIONS.ADD_FOLLOWUP_QUESTION:\r\n      return {\r\n        ...state,\r\n        questions: [...state.questions, action.payload]\r\n      };\r\n    \r\n    case ACTIONS.SET_RESUME_ANALYSIS:\r\n      return { ...state, resumeAnalysis: action.payload };\r\n    \r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\n// Provider component\r\nexport function InterviewProvider({ children }) {\r\n  const [state, dispatch] = useReducer(interviewReducer, initialState);\r\n\r\n  // Initialize socket connection\r\n  useEffect(() => {\r\n    const socket = io('http://localhost:5000', {\r\n      transports: ['websocket'],\r\n      autoConnect: false\r\n    });\r\n\r\n    socket.on('connect', () => {\r\n      dispatch({ type: ACTIONS.SET_CONNECTED, payload: true });\r\n      console.log('Connected to server');\r\n    });\r\n\r\n    socket.on('disconnect', () => {\r\n      dispatch({ type: ACTIONS.SET_CONNECTED, payload: false });\r\n      console.log('Disconnected from server');\r\n    });\r\n\r\n    socket.on('metrics_update', (data) => {\r\n      dispatch({ type: ACTIONS.UPDATE_METRICS, payload: data.metrics });\r\n    });\r\n\r\n    socket.on('error', (error) => {\r\n      dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\r\n      toast.error('Connection error: ' + error.message);\r\n    });\r\n\r\n    dispatch({ type: ACTIONS.SET_SOCKET, payload: socket });\r\n\r\n    return () => {\r\n      socket.disconnect();\r\n    };\r\n  }, []);\r\n\r\n  // API functions\r\n  const api = {\r\n    // Health check\r\n    checkHealth: async () => {\r\n      try {\r\n        const response = await axios.get('/api/health');\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Health check failed:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Upload resume\r\n    uploadResume: async (file) => {\r\n      dispatch({ type: ACTIONS.SET_LOADING, payload: true });\r\n      try {\r\n        const formData = new FormData();\r\n        formData.append('resume', file);\r\n\r\n        const response = await axios.post('/api/upload-resume', formData, {\r\n          headers: {\r\n            'Content-Type': 'multipart/form-data',\r\n          },\r\n        });\r\n\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n        return response.data;\r\n      } catch (error) {\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n        dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\r\n        toast.error('Failed to upload resume: ' + error.message);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Start interview\r\n    startInterview: async (candidateName, questions) => {\r\n      dispatch({ type: ACTIONS.SET_LOADING, payload: true });\r\n      try {\r\n        const response = await axios.post('/api/start-interview', {\r\n          candidate_name: candidateName,\r\n          questions: questions\r\n        });\r\n\r\n        const { session_id } = response.data;\r\n        dispatch({ type: ACTIONS.SET_SESSION_ID, payload: session_id });\r\n        dispatch({ type: ACTIONS.SET_CANDIDATE_NAME, payload: candidateName });\r\n        dispatch({ type: ACTIONS.SET_QUESTIONS, payload: questions });\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n\r\n        // Join socket room\r\n        if (state.socket) {\r\n          state.socket.emit('join_session', { session_id });\r\n        }\r\n\r\n        toast.success('Interview session started!');\r\n        return response.data;\r\n      } catch (error) {\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n        dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\r\n        toast.error('Failed to start interview: ' + error.message);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Process video frame\r\n    processFrame: async (frameData) => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        // Convert base64 to blob for file upload\r\n        const base64Data = frameData.split(',')[1]; // Remove data:image/jpeg;base64, prefix\r\n        const byteCharacters = atob(base64Data);\r\n        const byteNumbers = new Array(byteCharacters.length);\r\n        for (let i = 0; i < byteCharacters.length; i++) {\r\n          byteNumbers[i] = byteCharacters.charCodeAt(i);\r\n        }\r\n        const byteArray = new Uint8Array(byteNumbers);\r\n        const blob = new Blob([byteArray], { type: 'image/jpeg' });\r\n        \r\n        // Create FormData for file upload\r\n        const formData = new FormData();\r\n        formData.append('frame', blob, 'frame.jpg');\r\n        formData.append('session_id', state.sessionId);\r\n\r\n        const response = await axios.post('/api/process-frame', formData, {\r\n          headers: {\r\n            'Content-Type': 'multipart/form-data',\r\n          },\r\n        });\r\n\r\n        // Update metrics with the response data\r\n        if (response.data.success) {\r\n          // Update metrics based on the response\r\n          const metricsUpdate = {\r\n            face_detected: response.data.face_detected,\r\n            eyeContactPercentage: response.data.eye_contact ? 100 : 0,\r\n            confidenceScore: response.data.confidence || 0\r\n          };\r\n          \r\n          // If we have eye contact metrics, update them too\r\n          if (response.data.eye_contact_metrics) {\r\n            metricsUpdate.eyeContactDuration = response.data.eye_contact_metrics.total_eye_contact_time;\r\n            metricsUpdate.eyeContactStreak = response.data.eye_contact_metrics.current_streak;\r\n            metricsUpdate.longestEyeContactStreak = response.data.eye_contact_metrics.longest_streak;\r\n            metricsUpdate.eyeContactWarnings = response.data.eye_contact_metrics.warnings_triggered;\r\n          }\r\n          \r\n          dispatch({ type: ACTIONS.UPDATE_METRICS, payload: metricsUpdate });\r\n        }\r\n\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Frame processing error:', error);\r\n        // Don't show toast for frame processing errors as they're frequent\r\n      }\r\n    },\r\n\r\n    // Process audio\r\n    processAudio: async (audioData) => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        const response = await axios.post('/api/process-audio', {\r\n          session_id: state.sessionId,\r\n          audio_data: audioData\r\n        });\r\n\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Audio processing error:', error);\r\n      }\r\n    },\r\n\r\n    // End interview\r\n    endInterview: async () => {\r\n      if (!state.sessionId) return;\r\n\r\n      dispatch({ type: ACTIONS.SET_LOADING, payload: true });\r\n      try {\r\n        const response = await axios.post(`/api/end-interview/${state.sessionId}`);\r\n        \r\n        dispatch({ type: ACTIONS.SET_FINAL_RESULTS, payload: response.data.final_report });\r\n        dispatch({ type: ACTIONS.SET_INTERVIEW_COMPLETED, payload: true });\r\n        dispatch({ type: ACTIONS.SET_INTERVIEW_ACTIVE, payload: false });\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n\r\n        toast.success('Interview completed successfully!');\r\n        return response.data;\r\n      } catch (error) {\r\n        dispatch({ type: ACTIONS.SET_LOADING, payload: false });\r\n        dispatch({ type: ACTIONS.SET_ERROR, payload: error.message });\r\n        toast.error('Failed to end interview: ' + error.message);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Get session details\r\n    getSessionDetails: async (sessionId) => {\r\n      try {\r\n        const response = await axios.get(`/api/sessions/${sessionId}`);\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to get session details:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Get all sessions\r\n    getAllSessions: async () => {\r\n      try {\r\n        const response = await axios.get('/api/sessions');\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to get sessions:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Get current metrics for a session\r\n    getCurrentMetrics: async (sessionId) => {\r\n      try {\r\n        const response = await axios.get(`/api/sessions/${sessionId}/metrics`);\r\n        if (response.data.success) {\r\n          dispatch({ type: ACTIONS.UPDATE_METRICS, payload: response.data.metrics });\r\n        }\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to get current metrics:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Request metrics update via WebSocket\r\n    requestMetricsUpdate: () => {\r\n      if (state.socket && state.sessionId) {\r\n        state.socket.emit('request_metrics', { session_id: state.sessionId });\r\n      }\r\n    },\r\n\r\n    // Submit answer and get follow-up question\r\n    submitAnswer: async (questionId, answerText, currentQuestion) => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        const response = await axios.post('/api/submit-answer', {\r\n          session_id: state.sessionId,\r\n          question_id: questionId,\r\n          answer_text: answerText,\r\n          current_question: currentQuestion\r\n        });\r\n\r\n        if (response.data.success) {\r\n          // Update metrics with the response\r\n          dispatch({ type: ACTIONS.UPDATE_METRICS, payload: response.data.updated_metrics });\r\n          \r\n          // Store the follow-up question\r\n          if (response.data.followup_question) {\r\n            dispatch({ \r\n              type: ACTIONS.ADD_FOLLOWUP_QUESTION, \r\n              payload: response.data.followup_question \r\n            });\r\n          }\r\n        }\r\n\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to submit answer:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Generate follow-up question\r\n    generateFollowupQuestion: async (currentQuestion, previousAnswer, questionHistory) => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        const response = await axios.post('/api/generate-followup-question', {\r\n          session_id: state.sessionId,\r\n          current_question: currentQuestion,\r\n          previous_answer: previousAnswer,\r\n          question_history: questionHistory\r\n        });\r\n\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to generate follow-up question:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Request eye contact status update\r\n    requestEyeContactStatus: () => {\r\n      if (state.socket && state.sessionId) {\r\n        state.socket.emit('request_eye_contact_status', { session_id: state.sessionId });\r\n      }\r\n    },\r\n\r\n    // Get current eye contact status\r\n    getEyeContactStatus: async () => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        const response = await axios.get(`/api/eye-contact-status/${state.sessionId}`);\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to get eye contact status:', error);\r\n        throw error;\r\n      }\r\n    },\r\n\r\n    // Analyze resume\r\n    analyzeResume: async (resumeFile) => {\r\n      if (!state.sessionId) return;\r\n\r\n      try {\r\n        const formData = new FormData();\r\n        formData.append('resume', resumeFile);\r\n        formData.append('session_id', state.sessionId);\r\n\r\n        const response = await axios.post('/api/analyze-resume', formData, {\r\n          headers: {\r\n            'Content-Type': 'multipart/form-data',\r\n          },\r\n        });\r\n\r\n        if (response.data.success) {\r\n          // Store resume analysis in context\r\n          dispatch({ \r\n            type: ACTIONS.SET_RESUME_ANALYSIS, \r\n            payload: response.data.resume_analysis \r\n          });\r\n        }\r\n\r\n        return response.data;\r\n      } catch (error) {\r\n        console.error('Failed to analyze resume:', error);\r\n        throw error;\r\n      }\r\n    }\r\n  };\r\n\r\n  // Utility functions\r\n  const utils = {\r\n    // Get current question\r\n    getCurrentQuestion: () => {\r\n      return state.questions[state.currentQuestionIndex] || null;\r\n    },\r\n\r\n    // Move to next question\r\n    nextQuestion: () => {\r\n      if (state.currentQuestionIndex < state.questions.length - 1) {\r\n        dispatch({ \r\n          type: ACTIONS.SET_CURRENT_QUESTION, \r\n          payload: state.currentQuestionIndex + 1 \r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n\r\n    // Move to previous question\r\n    previousQuestion: () => {\r\n      if (state.currentQuestionIndex > 0) {\r\n        dispatch({ \r\n          type: ACTIONS.SET_CURRENT_QUESTION, \r\n          payload: state.currentQuestionIndex - 1 \r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    },\r\n\r\n    // Reset state\r\n    resetState: () => {\r\n      dispatch({ type: ACTIONS.RESET_STATE });\r\n    },\r\n\r\n    // Connect socket\r\n    connectSocket: () => {\r\n      if (state.socket && !state.isConnected) {\r\n        state.socket.connect();\r\n      }\r\n    },\r\n\r\n    // Disconnect socket\r\n    disconnectSocket: () => {\r\n      if (state.socket && state.isConnected) {\r\n        state.socket.disconnect();\r\n      }\r\n    }\r\n  };\r\n\r\n  const value = {\r\n    ...state,\r\n    api,\r\n    utils,\r\n    dispatch\r\n  };\r\n\r\n  return (\r\n    <InterviewContext.Provider value={value}>\r\n      {children}\r\n    </InterviewContext.Provider>\r\n  );\r\n}\r\n\r\n// Custom hook to use the context\r\nexport function useInterview() {\r\n  const context = useContext(InterviewContext);\r\n  if (!context) {\r\n    throw new Error('useInterview must be used within an InterviewProvider');\r\n  }\r\n  return context;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}